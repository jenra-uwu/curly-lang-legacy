# statically type - types are inferred
# a variable must remain the same type through its lifetime

variable = expression # assignment

with var1 = expression, # create a scope in which var[123] are used
     var2 = expression, # these are the only way to define variables in functions, loops, and conditions
	 var3 = expression,
	 f var1 var2 var3

function: \type1 type2. type3 # function declaration
function arg1 arg2 = expression # implementation
# a function can only have one signature (type1 type2): return_type

[type] # list of values of type
[[type]] # list of list of values of type
<type> # generator of values of type

function arg1 (function arg2 arg3) # function application
function arg1 # lazy evaluation
function *list # currying

if condition then expression # if statement
if condition then expression else expression # if else statement

debug expression # can place anywhere, prints out a message like this if debug is enabled:
# (db) expression evaluated to value on file.curly:lino:charno

a..b:c # numbers in [a, b) with step size c (negative is backwards) as a generator
list[i,j,k] # get the kth element of the jth element of the ith element of list
dict['a'] # get the value of key a in dict
list[a..b:c] # get the sublist of list with indices in range (a..b:c)
x in set # check if x is in set

# list compehensions are generated lazily
(for i in iter f i) # creates a generator with results of expression as items
[for i in iter f i] # creates a list
{for i in iter f i} # creates a set
(with acc = value, for i in iter acc = f acc i) # folds iterable into a single value
# pass - does not return a value
# stop - halts a loop
# nil - null, counts as a value
# true, false, and, or, xor

# quantifiers
for all i in iter f i # checks that all elements of the iterable follow some predicate
for some i in iter f i # checks that some element of the iterable follow some predicate

# filtering
[x in iter where f x] # list
(x in iter where f x) # generator
{x in list where f x} # generator that exits on the first failure
# you can run the above multiple times to get the next one

"string owo" # a string
'a' # a character
"" expression # expression as a string /concatenation

# type names: char, byte, short, int, long, float, double, string, obj, list, set, dict, gen, type, func

# example: fibonacci
fib: \int. int
fib 0 = 1
fib 1 = 1
fib n: int = (fib n - 1) + (fib n - 2)

instance = new type arg1 arg2 arg3

# things the parser still doesn't have:
#  - getting attributes from structures
#  - structures
#  - subscripting
#  - lists
#  - pattern matching
#  - types
#  - anonymous functions
