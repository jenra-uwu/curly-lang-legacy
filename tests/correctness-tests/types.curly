# types:
# & - intersection type
# * - product type
# | - union type
# >> - function type
# *type - generator of type
# [type] - list of type

# n: (a:Int & b:Bool) = {2, false} # succeeds
# y: Int = 0 # succeeds
# y = 2 # succeeds
# t: Type = int # succeeds
# l = [1,2,3] # succeeds
# l2 = ["a", "b", 3] # fails
# y = "" # fails
# y: String = "" # fails
# x: String = x # fails
# y # succeeds
# z # fails

# Pair: Type = int * int
# p: Pair = {5, 4}

# Comp: type = rect: (x: float & y: float) | polar: (r: float & theta: float)
# z1: Comp = {r = 1.0, theta = 2.0}
# z2: Comp = {1.0, 2.0}

# Tree: (Type >> Type)
# Tree: Type = leaf: bool | branch: tree * tree
# t1: Tree = {
#	branch = {
#		leaf = true, leaf = false
#	}, leaf = false
# }
# t2: Tree = {{true, false}, false}
# test: Bool = t2.branch.0
# test: Tree = false
# test2: [Tree] = [test, {false, true}]

# y: Bool = for all i in [1,2,3] i = true
# y: Int = if true then 0 else false

# x: *Int = x in [1,2,3] where x < 3 and x != 1

# Maybe: (Type >> Enum)
# Maybe T = Just T | Nothing

# x test:Int = 2

Test: Enum = A | B
t1: Test = A
t2: Test = B

# Linked: Type >> Type
# Linked T: Type = T * (Maybe (Linked T))
# iterate: (Linked Int) >> *Int
# iterate l: (Linked Int) = gen l.0 (*(iterate l.1))
