# types:
# & - intersection type
# * - product type
# | - union type
# >> - function type
# *type - generator of type
# [type] - list of type

# y: (a:int & b:bool) = [1,2,3,4]
# y: int = 0 # succeeds
# y = 2 # succeeds
# t: type = int # succeeds
# l = [1,2,3] # succeeds
# l2 = ["a", "b", 3] # fails
# y = "" # fails
# y: string = "" # fails
# x: string = x # fails
# y # succeeds
# z # fails

# pair: type = int * int
# p: pair = {5, 4}

comp: type = rect: (x: float & y: float) | polar: (r: float & theta: float)
z1: comp = {rect = {x = 1.0, y = 2.0}}
z2: comp = {rect = {1.0, 2.0}}

# tree: (type >> type)
tree: type = leaf: bool | branch: ((tree ) * (tree ))
t1: (tree ) = {
	branch = {
		{branch = {
			{true}, {false}
		}}, {false}
	}
}
t2: (tree ) = {
	{
		{{
			{true}, {false}
		}}, {false}
	}
}

# linked: type >> type
# linked t: type = t * (linked t)
# iterate: (linked obj) >> *obj
# iterate l: (linked obj) = gen l.0 (*(iterate l.1))
